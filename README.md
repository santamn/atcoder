# AtCoder知見シート

## 気を付けることリスト
- B問題
  - 前列挙や3重ループなどを使う愚直解の可能性をまず考える

- 2変数あるきは1変数固定してみるのが基本

### インタラクティブ問題の注意点

proconio::input!マクロをデフォルトで使う場合、ジャッジ環境では入力を一度に全部読み取ってしまうため、一行ずつ読み取るように以下のようにfromを指定する必要がある。

```rust
use proconio::{input, source::line::LineSource};
use std::io::{BufRead, BufReader};

fn main() {
    let mut source = LineSource::new(BufReader::new(std::io::stdin()));
    input! {
        from &mut source,
        n: usize,
    }

  ...
}
```

参照：[abc269 E問題](abc269/src/main.rs)

## 問題について

ABCの各問題に関するざっくりとした傾向 

- A: 入力を受け取って計算して出力するレベル
- B: ループを一回回すレベル
- C: 累積和をO(N^2)からO(N)にするレベル
- D: データ構造に関する知識が求められる
- E,F: 本番。グラフに関する問題とか少し本格的なDPが出がち
- G: なんでもありの難問。高度数学で一発な事もあるけどあてにしてはいけない
- Ex: 解けない

## データ構造

今まで使ったデータ構造

- Graph: 言わずと知れたデータ構造。DFSやBFSなどを使うとノードを$O(|V|)$で全探索できる。
  - 木: 連結で閉路を持たない(無向)グラフ
    - 離心数: 節点vからもっとも離れた節点wまでのパス(v,w)の長さ。ε(v)と書く
    - 半径: 離心率の最小値。min_{v ∈ V} ε(v) : 一回のDFS/BFSで求められる
    - 直径: 離心率の最大値。min_{v ∈ V} ε(v) : 一度あるvから距離最大のノードをDFS/BFSで求め、そのノードからさらに距離最大のノードを求める
    - 中心: 離心数が最小の節点
    - 重心: 根vの直接の子以下の最大部分木の節点数が最小となる場合、vを重心と呼ぶ
- Nex: nex[i][j] = 文字列Sの[0,i)番目で文字種jが初めに現れるインデックス。部分列&辞書式順序と聞いたらこれ。
- Que: FILO
- Stack: FIFO
- Union Find: 結合とその判定を逆アッカーマン関数でやってくれる優れもの。切断はできないので要注意。

## アルゴリズム

今までに使ったアルゴリズム

- 二分探索法  
  言わずと知れた有名アルゴリズム。ソート(O(N*logN))された配列からO(logN)で特定の要素を見つけることができる。
  また、それだけにとどまらず、最小/最大の〇〇を求めると言ったときにも使うことができる。

- 動的計画法  
  以下の二つを満たすアルゴリズムらしい
  > 1. 帰納的な関係の利用：より小さな問題例の解や計算結果を帰納的な関係を利用してより大きな問題例を解くのに使用する
  > 2. 計算結果の記録：小さな問題例、計算結果から記録し、同じ計算を何度も行うことを避ける  
  > by [Wikipedia](https://ja.wikipedia.org/wiki/%E5%8B%95%E7%9A%84%E8%A8%88%E7%94%BB%E6%B3%95)

  次のような二つの種類がある。
  1. トップダウン: メモ化再帰
  2. ボトムアップ: [分割統治法](https://ja.wikipedia.org/wiki/%E5%88%86%E5%89%B2%E7%B5%B1%E6%B2%BB%E6%B3%95)、漸化式ループ
  
  参考:[動的計画法（Dynamic Programming）をサルでも分かるように説明する - その１（フィボナッチ数列）](https://jabba.cloud/20161020172918)

  生じる部分問題の全体集合が明らかな場合はボトムアップの方が良い。

  - 配るDP/もらうDP  
    ボトムアップDPを実装する際に、値をもらう側を主体にして実装するか、渡す側を主体にして実装するかの違い。普通はどちらでも問題なくできるが、問題によってはどちらか一方の計算量が増えてしまうことがあるらしい。

- 貪欲法  
  問題を部分問題に分割し、それぞれで最適化を行うこと(だけ)を考える。
  > このアルゴリズムは問題の要素を複数の部分問題に分割し、それぞれを独立に評価を行い、評価値の高い順に取り込んでいくことで解を得るという方法である。動的計画法と異なり保持する状態は常に一つであり、一度選択した要素を再考する事は無い。このため得られる解は最適解であるという保証は無いが部分問題の解法と単純なソートのみでプログラムを実装することが可能であり、多くの問題に対して多項式時間での近似アルゴリズムとなる。  
  > by [Wikipedia](https://ja.wikipedia.org/wiki/%E8%B2%AA%E6%AC%B2%E6%B3%95)

  とりあえず部分問題だけを考えて、それらを取り込んで全体の解を作るという都合上、貪欲法を使って問題を解いたときに最適解が求められるかどうかは別途検証が必要である。

- ビット全探索  
  値が2値のものをn個合わせると2^n個の組み合わせができる。
  n < 20くらいなら可能。

- グラフ
  - DFS/BFS  
    深さ優先/幅優先でグラフの全ノードを探索するアルゴリズム。$O(|V|)$
  - Dijkstra  
    バイナリヒープを使うことであるノードから全てのノード以外への距離を$O((|E|+|V|)log|V|)$で求めることができるアルゴリズム。  
    ヒープから取り出したノードに既により短いパスが設定されている場合を枝刈りすることで速くできる。
  - 強連結成分分解  
    お互いに行き来可能な頂点集合を一つにまとめるアルゴリズム。$O(|V|+|E|)$

- いもす法  
  累積和のアルゴリズムを多次元，多次数に拡張したもの。入ったところで+1、出たところで-1として数える。